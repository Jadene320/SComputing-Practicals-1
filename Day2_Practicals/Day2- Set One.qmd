---
title: "Statistical Computing - Day2"
author: "Jadene"
format: html
editor: visual
---

# Additional Exercises: Set One

## Exercise One

#### Question One

```{r}
#log(i+1) for i= 0,...100
i <- 1:100
sum_log <- log(i +1)
average <- mean(sum_log)
```

#### Question 2

```{r}
set.seed(20190128)
y <- rexp(10000) #generate 10000 random numbers from an exp distribution
```

#### Question 3

```{r}
max(y) #max value generated
which.max(y) #what position holds the max
```

#### Question 4

```{r}
#how many values are greater than 2 
values_greater2 <- y[y>2]
length_greater2 <- length(values_greater2)
length_y <- length(y)

percent_greater2 <- (length_greater2/length_y) * 100
print(percent_greater2)
```

#### Question 5

```{r}
y2 <- y[seq(1,10000, by =2)]
```

#### Question 6

```{r}
#Find val in y2 > 3, and replacw with 3. Calculate average. 
val_greater3 <- y2[y2>3]
y3 <- replace(y2, val_greater3, 3)

avg_y3 <- mean(y3)
print(avg_y3)
```

#### Question 7

```{r}
#Calc Sample Variance
sq_deviations <- (y3-avg_y3)^2
sum_sq <- sum(sq_deviations)
n <- length(y3) 
sample_var <- sum_sq/(n-1)
print(sample_var)

print(var(y3))
```

## Exercise Two

#### Question 1

Solve this problem using matrices.

```{r}
#x = number on tree1
#y = number on tree 2
#1: y-1 = x+1
#2: y+1 = 2(x-1)

A <- rbind(c(1, -1),
                c(-2,1))
b <- c(-2, -3)
solve(A,b)
```

The number of birds on Tree 1 is 5. The number on Tree 2 is 7.

## Exercise Three

```{r}
#one door with a car, two with goats
set.seed(1)
doors <- c(1,2,3) 
win_counter = 0 

#Simulate the game 10000 times (This is a situation where you don't switch doors at all)
for(i in 1:10000){
  prize_in_door = sample(doors, size =1) #Randomly choose the door that has the prize
  my_choice =2 #This can be 1 2 or 3 
  if(my_choice == prize_in_door)
  {
    win_counter = win_counter+1
  }
}

print(win_counter/10000)
```

```{r}
door_to_reveal <- function(doors, prize_in_door, my_choice){
  if (prize_in_door == my_choice){ #if my choice is the prize door 
    reveal = sample(doors[-my_choice], size =1) #then, the only door that can be revealed is one that doesn't have the prize
  }
  else { #but if I chose a door that doesnt have the prize then only one other door can be revealed. 
    reveal = doors[-c(my_choice, prize_in_door)]
  }
  
}
```

Now, we need to calculate what the probability is if you switched every time you played.

```{r}
set.seed(1)
win_counter = 0

for (i in 1:10000){
  prize_in_door = sample(doors,1)
  my_choice = 1
  reveal = door_to_reveal(doors, prize_in_door, my_choice)
  #Now change the door
  new_choice = doors[-c(my_choice, reveal)] #Let the new choice be anything that isnt the door that we already picked and not the one already revealed.
  if(prize_in_door == new_choice)
  {
    win_counter = win_counter + 1
  }
}

print(win_counter/10000)
```

The increased prob. shows that it is in the contestants favor to switch doors.

## Exercise 4

```{r}
#perform a weighted linear reg
set.seed(1)
x <- seq(1,100)
e <- rnorm(100, 0, 0.2^2)
y <- sin(x/10) + e 
n <- length(x)

#Creating the custom Loess function for smoothing and plot
#f is span
customLowess <- function(x, y, f=0.5){ 
  
  fit <- loess(x, y, f= span, iter = iter)
  return(fit)
}

#Compare the function that you created with that of R build in LOESS
def_lowess <- lowess(x, y, f = 0.5, iter = 0)
```
